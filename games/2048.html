<!-- games/2048.html -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>2048 — Old School</title>
<style>
  /* Old-school CRT vibe */
  :root { color-scheme: dark; }
  * { box-sizing: border-box; }
  body {
    margin: 0; background: #000; color: #0f0; font-family: "Courier New", monospace;
    min-height: 100vh; display: grid; place-items: center;
  }
  .wrap { width: 360px; max-width: 92vw; }
  header { text-align: center; margin-bottom: 12px; }
  h1 { color: #ff0; text-shadow: 2px 2px #f00; margin: 8px 0; font-size: 24px; }
  .meta { display: flex; justify-content: space-between; align-items: center; gap: 8px; }
  .badge {
    border: 3px double #fff; background: #111; color: #0ff; padding: 6px 10px; min-width: 120px; text-align: center;
  }
  .btn {
    color: #0ff; border: 2px solid #0ff; padding: 4px 8px; background: transparent; cursor: pointer; font-weight: bold;
  }
  .btn:hover { background: #0ff; color: #000; }
  .board {
    margin-top: 12px; background: #111; border: 4px double #fff; padding: 8px;
    display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px;
  }
  .cell {
    height: 70px; background: #000; border: 2px solid #333; display: grid; place-items: center;
    color: #0f0; font-weight: bold; font-size: 18px;
    box-shadow: inset 0 0 8px rgba(0,255,0,0.2);
  }
  /* Tile colors by value (retro neon palette) */
  .v2   { color:#000; background:#0f0; }
  .v4   { color:#000; background:#0ff; }
  .v8   { color:#000; background:#ff0; }
  .v16  { color:#000; background:#f90; }
  .v32  { color:#000; background:#f60; }
  .v64  { color:#000; background:#f30; }
  .v128 { color:#000; background:#ff3b3b; }
  .v256 { color:#000; background:#ff6bd6; }
  .v512 { color:#000; background:#b15cff; }
  .v1024{ color:#000; background:#7a2fff; }
  .v2048{ color:#000; background:#2d2df5; }
  .status { margin-top: 8px; text-align: center; color: #ff0; min-height: 20px; }
  footer { margin-top: 12px; text-align: center; color:#888; font-size: 12px; animation: blink 1s step-start infinite; }
  @keyframes blink { 50% { opacity: 0; } }

  /* Mobile swipe hint */
  .hint { color:#0ff; text-align:center; font-size: 12px; margin-top: 6px; }
</style>
</head>
<body>
<div class="wrap" role="application" aria-label="2048 game">
  <header>
    <h1>2048 — Old School</h1>
    <div class="meta">
      <div class="badge">Score: <span id="score">0</span></div>
      <div class="badge">Best: <span id="best">0</span></div>
      <button class="btn" id="new">New game</button>
    </div>
    <div class="hint">Use Arrow keys or WASD. On mobile, swipe.</div>
  </header>

  <div id="board" class="board" aria-live="polite"></div>
  <div id="status" class="status"></div>

  <footer>PRESS START</footer>
</div>

<script>
/* 2048 logic — pure JS */
const SIZE = 4;
let grid, score, best, won, over;

const boardEl = document.getElementById('board');
const scoreEl = document.getElementById('score');
const bestEl  = document.getElementById('best');
const statusEl= document.getElementById('status');
document.getElementById('new').addEventListener('click', init);

function loadBest(){ return Number(localStorage.getItem('best2048')||0); }
function saveBest(v){ localStorage.setItem('best2048', String(v)); }

function init(){
  grid = Array.from({length: SIZE}, () => Array(SIZE).fill(0));
  score = 0; won = false; over = false;
  best = loadBest();
  spawn(); spawn();
  render();
  setStatus('');
}
init();

/* Rendering */
function render(){
  boardEl.innerHTML = '';
  for (let r=0;r<SIZE;r++){
    for (let c=0;c<SIZE;c++){
      const v = grid[r][c];
      const cell = document.createElement('div');
      cell.className = 'cell' + (v ? ' v'+v : '');
      cell.setAttribute('role','gridcell');
      cell.setAttribute('aria-label', v ? v : 'empty');
      cell.textContent = v ? v : '';
      boardEl.appendChild(cell);
    }
  }
  scoreEl.textContent = score;
  bestEl.textContent = Math.max(best, score);
}

/* Spawning */
function emptyCells(){
  const out = [];
  for (let r=0;r<SIZE;r++) for (let c=0;c<SIZE;c++) if (!grid[r][c]) out.push([r,c]);
  return out;
}
function spawn(){
  const empties = emptyCells();
  if (!empties.length) return false;
  const [r,c] = empties[Math.floor(Math.random()*empties.length)];
  grid[r][c] = Math.random() < 0.9 ? 2 : 4;
  return true;
}

/* Movement helpers */
function slideRow(row){
  // Compress non-zero
  const arr = row.filter(v => v);
  // Merge adjacent equals
  for (let i=0;i<arr.length-1;i++){
    if (arr[i] === arr[i+1]){
      arr[i] *= 2;
      score += arr[i];
      arr[i+1] = 0;
      i++; // skip next
    }
  }
  // Remove zeros and pad
  const merged = arr.filter(v => v);
  while (merged.length < SIZE) merged.push(0);
  return merged;
}

function rotateGrid(times){
  // Rotate clockwise 'times' times
  for (let t=0;t<times;t++){
    const g = Array.from({length: SIZE}, () => Array(SIZE).fill(0));
    for (let r=0;r<SIZE;r++){
      for (let c=0;c<SIZE;c++){
        g[c][SIZE-1-r] = grid[r][c];
      }
    }
    grid = g;
  }
}

function move(dir){
  if (over) return false;
  const before = JSON.stringify(grid);

  // Map directions to rotations so we always slide left
  // 0: left, 1: up, 2: right, 3: down
  const rotations = {0:0, 1:1, 2:2, 3:3}[dir];
  rotateGrid(rotations);

  // Slide each row left
  for (let r=0;r<SIZE;r++){
    grid[r] = slideRow(grid[r]);
  }

  // Rotate back
  rotateGrid((4 - rotations) % 4);

  const after = JSON.stringify(grid);
  if (before !== after){
    if (!spawn()) {
      // No spawn means no empty space; check game over
      if (!canMove()) gameOver();
    }
    render();
    checkWin();
    updateBest();
    return true;
  } else {
    // If nothing changed, still check for game over
    if (!canMove()) gameOver();
    return false;
  }
}

function canMove(){
  if (emptyCells().length) return true;
  // Check adjacent merges
  for (let r=0;r<SIZE;r++){
    for (let c=0;c<SIZE;c++){
      const v = grid[r][c];
      if (r+1<SIZE && grid[r+1][c] === v) return true;
      if (c+1<SIZE && grid[r][c+1] === v) return true;
    }
  }
  return false;
}

function checkWin(){
  if (won) return;
  for (let r=0;r<SIZE;r++){
    for (let c=0;c<SIZE;c++){
      if (grid[r][c] === 2048){
        won = true;
        setStatus('You made 2048! Keep going or start new.');
        return;
      }
    }
  }
}

function gameOver(){
  over = true;
  setStatus('Game Over — Press New game to try again.');
}

function updateBest(){
  const b = Math.max(loadBest(), score);
  saveBest(b);
  best = b;
}

function setStatus(msg){ statusEl.textContent = msg; }

/* Input: keyboard */
addEventListener('keydown', e => {
  const k = e.key.toLowerCase();
  const map = { arrowleft:0, a:0, arrowup:1, w:1, arrowright:2, d:2, arrowdown:3, s:3 };
  if (k in map){
    e.preventDefault();
    move(map[k]);
  }
});

/* Input: touch swipe (basic) */
let touchStart = null;
boardEl.addEventListener('touchstart', e => {
  const t = e.changedTouches[0];
  touchStart = { x: t.clientX, y: t.clientY };
}, {passive:true});

boardEl.addEventListener('touchend', e => {
  if (!touchStart) return;
  const t = e.changedTouches[0];
  const dx = t.clientX - touchStart.x;
  const dy = t.clientY - touchStart.y;
  const ax = Math.abs(dx), ay = Math.abs(dy);
  touchStart = null;
  if (Math.max(ax, ay) < 24) return; // ignore tiny swipes
  if (ax > ay){
    move(dx < 0 ? 0 : 2); // left or right
  } else {
    move(dy < 0 ? 1 : 3); // up or down
  }
});
</script>
</body>
</html>
